package koreait.day02;

public class C05_IntegerVar {

	public static void main(String[] args) { // main 메소드 시작- 지역변수 는 이 메인 메소드 안에서만 선언됨.
		/*
		 * 1. main 메소드 안에서만 사용하는 지역변수를 선언합니다. 2. 기본형 (primitive) 데이터 타입 : 정수형식 byte,
		 * short, int, long 키워드(역할이 정해진 단어)
		 */
		byte n1; // byte 형식의 데이터를 저장할 공간. 이름 n1
		short n2;
		int n3;
		long n4;

		byte m1 = 100;
		short m2 = 100;
		int m3 = 100;
		long m4 = 100;

		int currentNo; // 변수명은 실제저장되는 값이 파악될 수 있는 단어로 만듦.

		// System.out.println(n1); - 오류남. 값이 없는 변수기 때문.
		System.out.println(m1);

		// 값의 대입(=)
		n1 = 123; // 대입문: 오른쪽 값/수식/변수가 왼쪽 변수로 대입. 123은 4바이트 리터럴임. byte나 short는 별도 리터럴표기방식이 없음.
					// 자동으로 값이 안넘치면 1, 2바이트로 줄여서 int 값을 저장함
//		n1= 999; //오류 이유: 127보다 큰 값
		n2 = 29999;
//		n2= -40000; // 오류 이유: -32768보다 작은 값
		n3 = 123456789;
//		n3= 123456789123; //이유: 2147483647보다 큰 값
//		n4= 1234567890123; //이유 : 1234567890123 리터럴은 int 리터럴이므로 표현오류임
		n4 = 123; // 이건 int리터럴 값으로 표현이 가능하기 때문에 오류가 안생기는 거임.
		n4 = 1234567890123L; // long 리터럴 표시는 L또는 l을 마지막에 써야 함.

		System.out.println("변수n1 = " + n1);
		System.out.println("변수n2 = " + n2);
		System.out.printf("변수 %s = %d\n", "n3", n3);
		System.out.printf("변수 %s = %d\n", "n4", n4);

	} // main 메소드 끝
		// 대입문 또는 리터럴 표시할 때의 값의 범위가 넘어가는 것을 overflow(오버플로우)라고 함.
}
/*
 * 변수 : 메모리에 저장된 값 중에서 변경할 수 있는 데이터를 말합니다. 변수는 프로그램이 실행되는 동안에 임시로 사용하는 메모리
 * 공간입니다. 데이터가 저장된 메모리에 접근하기 위해서 변수명(식별자)을 부여합니다. 변수 선언한다(변수명과 데이터 형식을 지정하는 것)
 * -> 메모리에 공간 할당 됩니다. 조사내용: 변수명을 정할 때의 규칙
 */
